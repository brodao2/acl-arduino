import {
  createConnection,
  TextDocuments,
  ProposedFeatures,
  InitializeParams,
  TextDocumentSyncKind,
  InitializeResult,
  CreateFile,
  ShowMessageRequestParams,
  WorkspaceFolder,
  CodeActionOptions,
  ExecuteCommandOptions,
  ShowDocumentParams,
  ShowMessageParams,
  MessageType,
  CompletionList,
} from "vscode-languageserver/node";

import { TextDocument } from "vscode-languageserver-textdocument";
import { ArduinoCli } from "./arduino-cli";
import { registerMessages } from "./messages";
import path = require("path");
import { ArduinoAction } from "./arduino-action";
import { fileURLToPath, pathToFileURL } from "url";
import { info } from "console";
import { getLanguageModes, LanguageModes } from "./languageModes";

// import {
// import { registerEditor } from './../../client/src/configEditor/index';
// import { CliVersion } from './../../client/src/app/editor/components/cli-version';
// doChangeConfiguration,
//   documentSettings,
//   doValidateTextDocument,
// } from "./utils";

const homedir: string = require("os").homedir();
export const ACL_HOME: string = path.join(homedir, ".aclabarduino");

const pack = { name: "acl-arduino-server", version: "0.0.1" };

// Create a connection for the server, using Node's IPC as a transport.
// Also include all preview / proposed LSP features.
const connection = createConnection(ProposedFeatures.all);

const _log = console.log;
const _error = console.error;
const _info = console.info;
const _warn = console.warn;
const _debug = console.debug;
console.log = (...data: any[]) => {
  const text: string = _logMessage(MessageType.Log, data.join("#"));
  if (text) {
    _log(text);
  }
};
console.error = (...data: any[]) => {
  const text: string = _logMessage(MessageType.Error, data.join("#"));
  if (text) {
    _error(text);
  }
};
console.info = (...data: any[]) => {
  const text: string = _logMessage(MessageType.Info, data.join("#"));
  if (text) {
    _info(text);
  }
};
console.warn = (...data: any[]) => {
  const text: string = _logMessage(MessageType.Warning, data.join("#"));
  if (text) {
    _warn(text);
  }
};
console.debug = (...data: any[]) => {
  const text: string = _logMessage(undefined, data.join("#"));
  if (text) {
    _debug(text);
  }
};
// Create a manager for open text documents
const documents: TextDocuments<TextDocument> = new TextDocuments(TextDocument);
let languageModes: LanguageModes;

// The workspace folder this server is operating on
let workspaceFolder: WorkspaceFolder | null;
let arduinoCli: ArduinoCli | null;
const MESSAGE_TYPES: string[] = ["", "E", "W", "I", "L"];

function _logMessage(level: MessageType, text: string) {
  //return `[(${process.pid}):${workspaceFolder.name}] ${MESSAGE_TYPES[level]}: ${text}`;
  return text.startsWith("-")
    ? undefined
    : `[${workspaceFolder.name.padEnd(15, " ")}] ${
        level ? MESSAGE_TYPES[level] : "D"
      }: ${text}`;
}

function log(message: string | string[]) {
  if (Array.isArray(message)) {
    connection.console.log(_logMessage(MessageType.Log, message.join("\n")));
  } else {
    connection.console.log(_logMessage(MessageType.Log, message));
  }
}

function error(message: string) {
  connection.console.error(_logMessage(MessageType.Error, message));
}

function warn(message: string) {
  connection.console.warn(_logMessage(MessageType.Warning, message));
}

function _doSendShowMessage(request: ShowMessageParams) {
  _logMessage(request.type, request.message);
  connection.sendNotification("window/showMessage", request);
}

function doSendInfoMessage(message: string) {
  _doSendShowMessage({ type: MessageType.Info, message: message });
}

function doSendErrorMessage(message: string) {
  _doSendShowMessage({ type: MessageType.Error, message: message });
}

function doSendWarningMessage(message: string) {
  _doSendShowMessage({ type: MessageType.Warning, message: message });
}

function doSendLogMessage(message: string) {
  _doSendShowMessage({ type: MessageType.Log, message: message });
}

function doSendShowMessageRequest(request: ShowMessageRequestParams) {
  connection
    .sendRequest("window/showMessageRequest", request)
    .then((resp: any) => {
      if (resp && resp.returnParams) {
        ArduinoAction.processResult(arduinoCli, resp.returnParams).then(
          (message: string) => {
            doSendInfoMessage(message);
          },
          (message: string) => {
            doSendErrorMessage(message);
          }
        );
      }
    })
    .catch((reason: any) => {
      doSendErrorMessage(reason);
    });
}

function doSendShowDocumentRequest(request: ShowDocumentParams) {
  connection
    .sendRequest("window/showDocument", request)
    .then((resp: any) => {
      if (resp && resp.success) {
        info("Document open");
      } else {
        error("Document not open");
      }
    })
    .catch((reason: any) => {
      error(reason);
    });
}

documents.onDidOpen((event) => {
  log(`Document opened: ${event.document.uri}`);
});

documents.onDidChangeContent((event) => {
  log(`onDidChangeContent: ${event.document.uri}`);

  if (event.document.uri.endsWith("aclabarduino.json")) {
    const data: any = JSON.parse(event.document.getText());
    const diagnostic: ShowMessageRequestParams = arduinoCli.checkEnvironment(
      data.cliVersion
    );

    if (diagnostic) {
      doSendShowMessageRequest(diagnostic);
    }
  }
});

documents.onDidClose((event) => {
  log(`onDidClose: ${event.document.uri}`);
});

documents.onDidSave((event) => {
  log(`onDidSave: ${event.document.uri}`);
});

documents.onWillSave((event) => {
  log(`onWillSave: ${event.document.uri}`);
});

// documents.onWillSaveWaitUntil((event, textEdit) => {
//   log(
//     `onWillSaveWaitUntil: ${event.document.uri}`
//   );
// });
connection.onCompletion(async (textDocumentPosition, token) => {
  const document = documents.get(textDocumentPosition.textDocument.uri);
  if (!document) {
    return null;
  }

  const mode = languageModes.getModeAtPosition(
    document,
    textDocumentPosition.position
  );
  if (!mode || !mode.doComplete) {
    return CompletionList.create();
  }
  const doComplete = mode.doComplete!;

  return doComplete(document, textDocumentPosition.position);
});

connection.onInitialize((params: InitializeParams): InitializeResult => {
  languageModes = getLanguageModes();

  documents.onDidClose((e) => {
    languageModes.onDocumentRemoved(e.document);
  });
  connection.onShutdown(() => {
    languageModes.dispose();
  });

  workspaceFolder = toUri(
    params.workspaceFolders
      .filter((value: WorkspaceFolder) => {
        return value.uri == params.initializationOptions.workspaceFolder;
      })
      .pop()
  );

  arduinoCli = ArduinoCli.initialize({ workspaceFolder: workspaceFolder });
  registerMessages(connection, arduinoCli);

  showBanner(params.clientInfo);

  log(
    `Started and initialize received. WS Count: ${params.workspaceFolders.length}`
  );

  return {
    serverInfo: {
      name: pack.name,
      version: pack.version,
    },
    capabilities: {
      textDocumentSync: {
        openClose: true,
        change: TextDocumentSyncKind.Full,
        save: true,
      },
      completionProvider: {
        resolveProvider: false,
      },
      codeActionProvider: getCodeActionProvider(),
      executeCommandProvider: getExecuteCommandProvider(),
    },
  };
});

connection.onInitialized(() => {
  const release: string = arduinoCli.getCurrentVersion();
  const diagnostic: ShowMessageRequestParams =
    arduinoCli.checkEnvironment(release);

  if (diagnostic) {
    doSendShowMessageRequest(diagnostic);
  }
});

connection.onDidChangeConfiguration((change) => {
  // doChangeConfiguration(change);
  // // Revalidate all open text documents
  documents.all().forEach(doValidateTextDocument);
  log(`onDidChangeConfiguration`);
});

connection.onDidChangeWatchedFiles((_change) => {
  // Monitored files have change in VSCode
  log(`onDidChangeWatchedFiles`);
  connection.console.log("We received an file change event");
});

connection.onShutdown(() => {
  log("Shutdowning server.");
  arduinoCli = null;
});

connection.onCodeAction((params) => {
  log("onCodeAction");
  log(JSON.stringify(params));

  // const textDocument = documents.get(params.textDocument.uri);
  // if (textDocument === undefined) {
  //   return undefined;
  // }

  // const title = "With User Input";
  // return [
  //   CodeAction.create(
  //     title,
  //     Command.create(
  //       title,
  //       "sample.fixMe",
  //       path.join(workspaceFolder, ".vscode", "aclabarduino.json"),
  //       CodeActionKind.QuickFix
  //     )
  //   ),
  // ];

  return [];
});

connection.onExecuteCommand(async (params) => {
  log("onExecuteCommand");
  log(JSON.stringify(params));

  if (params.command !== "sample.fixMe" || params.arguments === undefined) {
    return;
  }

  // const textDocument = documents.get(params.arguments[0]);
  // if (textDocument === undefined) {
  //   return;
  // }

  connection.workspace.applyEdit({
    documentChanges: [
      CreateFile.create(
        params.arguments[0],
        { ignoreIfExists: true },
        "createFile"
      ),
    ],
  });
});

// Make the text document manager listen on the connection
// for open, change and close text document events
documents.listen(connection);

// Listen on the connection
connection.listen();

function getCodeActionProvider(): boolean | CodeActionOptions {
  // {
  //   codeActionKinds: [CodeActionKind.QuickFix],
  // }  throw new Error('Function not implemented.');

  return false;
}

function getExecuteCommandProvider(): ExecuteCommandOptions {
  // {
  //   commands: ["sample.fixMe"],
  //  },
  return null;
}

function toUri(workspace: WorkspaceFolder): WorkspaceFolder {
  return {
    name: workspace.name,
    uri: fileURLToPath(workspace.uri),
  };
}

let isShowBanner: boolean = true;

function showBanner(clientInfo: any, force: boolean = false) {
  if (isShowBanner || force) {
    isShowBanner = false;
    // prettier-ignore
    {
      log(["",
    "--------------------------------------------------------------------------",
    `                       ___      ___               _        ___      ___  `,
    `     o O O            /   \\    / __|             | |      /   \\    | _ ) `, 
    `    o  _____          | - |   | (__              | |__    | - |    | _ \\ `, 
    `   []__[O]_           |_|_|    \\___|             |____|   |_|_|    |___/ `, 
    `  {======| _\\"""""/ _|"""""| _|"""""| _\\"""""/ _|"""""| _|"""""| _|"""""|`, 
    ` ./o=-000' "'-0^0-' "'-0^0-' "'-0^0-' "'-0^0-' "'-0^0-' "'-0^0-' "'-0^0-'`,
        "------------v-------------------------------------------------------------",
        `            | AC Lab Arduino Service ${pack.version}`,
        "            | https://github.com/brodao2/acl-arduino",
        "            | 2022 (c) Alan Cândido <brodao@gmail.com>",
        `            | Client : ${clientInfo.name} ${ clientInfo.version}`,
        "------------^------------------------------------------------------------"
      ]);
    } // prettier-ignore
  }
}
